#!/usr/bin/env zsh
#
# bsp-tree - ASCII tree visualization for bsp package
#
# Usage: bsp tree [options]
#
# Display window tree structure with ASCII art
#
# Version: 2.0.0

set -eo pipefail

# ============================================================================
# INITIALIZATION
# ============================================================================

# Source common utilities
SCRIPT_DIR="${0:A:h}"
source "$SCRIPT_DIR/bsp-common"

# Load _bspwm library
if [[ -f "/home/andronics/.dotfiles/lib/.local/bin/_bspwm" ]]; then
    source "/home/andronics/.dotfiles/lib/.local/bin/_bspwm"
else
    echo "Error: _bspwm library not found" >&2
    exit 1
fi

# ============================================================================
# HELP
# ============================================================================

tree-help() {
    cat <<'EOF'
Usage: bsp tree [options]

ASCII Tree Visualization for BSP

Display window tree structure with ASCII art showing hierarchy,
window properties, and current focus.

OPTIONS:
  -h, --help           Show this help message
  -d, --desktop NAME   Show tree for specific desktop (default: focused)
  -m, --monitor NAME   Show tree for specific monitor (default: focused)
  --all                Show trees for all desktops
  --no-color           Disable color output
  --json               Output raw tree JSON instead of ASCII

TREE SYMBOLS:
  │  Vertical line (parent-child connection)
  ├  Branch (has siblings below)
  └  Last branch (no siblings below)
  ─  Horizontal line
  ◆  Focused node
  ○  Normal node
  □  Floating node
  ■  Fullscreen node
  ⚑  Marked node

NODE STATES:
  T  Tiled
  F  Floating
  =  Fullscreen
  P  Pseudo-tiled

EXAMPLES:
  bsp tree                     # Show tree for focused desktop
  bsp tree --all               # Show trees for all desktops
  bsp tree -d 1                # Show tree for desktop 1
  bsp tree --no-color          # Disable colors

NOTES:
  - Tree shows window class and title
  - Focused node is highlighted
  - Colors indicate state (if enabled)
EOF
}

# ============================================================================
# TREE BUILDING
# ============================================================================

tree-get-node-info() {
    local node_id="$1"

    # Query node properties
    local class=""
    local title=""
    local state=""
    local flags=""
    local focused=false

    # Get class
    class=$(xprop -id "$node_id" WM_CLASS 2>/dev/null | grep -o '"[^"]*"' | head -1 | tr -d '"' || echo "unknown")

    # Get title
    title=$(xprop -id "$node_id" WM_NAME 2>/dev/null | grep -o '"[^"]*"' | head -1 | tr -d '"' || echo "untitled")

    # Truncate title
    if [[ ${#title} -gt 40 ]]; then
        title="${title:0:37}..."
    fi

    # Check if focused
    local focused_id
    focused_id=$(bspc query -N -n focused 2>/dev/null || echo "")
    if [[ "$node_id" == "$focused_id" ]]; then
        focused=true
    fi

    # Get state via bspc
    state=$(bspc query -T -n "$node_id" 2>/dev/null | jq -r '.client.state // "tiled"')

    # Get flags via bspc
    local marked=$(bspc query -T -n "$node_id" 2>/dev/null | jq -r '.marked // false')
    local locked=$(bspc query -T -n "$node_id" 2>/dev/null | jq -r '.locked // false')
    local sticky=$(bspc query -T -n "$node_id" 2>/dev/null | jq -r '.sticky // false')
    local private=$(bspc query -T -n "$node_id" 2>/dev/null | jq -r '.private // false')

    flags=""
    [[ "$marked" == "true" ]] && flags="${flags}M"
    [[ "$locked" == "true" ]] && flags="${flags}L"
    [[ "$sticky" == "true" ]] && flags="${flags}S"
    [[ "$private" == "true" ]] && flags="${flags}P"

    jq -n \
        --arg id "$node_id" \
        --arg class "$class" \
        --arg title "$title" \
        --arg state "$state" \
        --arg flags "$flags" \
        --argjson focused "$focused" \
        '{
            id: $id,
            class: $class,
            title: $title,
            state: $state,
            flags: $flags,
            focused: $focused
        }'
}

tree-format-node() {
    local node_info="$1"
    local use_color="${2:-true}"

    local class
    local title
    local state
    local flags
    local focused

    class=$(echo "$node_info" | jq -r '.class // "unknown"')
    title=$(echo "$node_info" | jq -r '.title // "untitled"')
    state=$(echo "$node_info" | jq -r '.state // "tiled"')
    flags=$(echo "$node_info" | jq -r '.flags // ""')
    focused=$(echo "$node_info" | jq -r '.focused // false')

    # Choose symbol based on state and focus
    local symbol="○"
    if [[ "$focused" == "true" ]]; then
        symbol="◆"
    elif [[ "$state" == "fullscreen" ]]; then
        symbol="■"
    elif [[ "$state" == "floating" ]]; then
        symbol="□"
    elif [[ -n "$flags" ]] && [[ "$flags" == *M* ]]; then
        symbol="⚑"
    fi

    # State abbreviation
    local state_abbrev=""
    case "$state" in
        tiled) state_abbrev="T" ;;
        floating) state_abbrev="F" ;;
        fullscreen) state_abbrev="=" ;;
        pseudo_tiled) state_abbrev="P" ;;
    esac

    # Build node display
    local node_display="$symbol $class - $title"

    if [[ -n "$state_abbrev" ]]; then
        node_display="$node_display [$state_abbrev]"
    fi

    if [[ -n "$flags" ]]; then
        node_display="$node_display {$flags}"
    fi

    # Apply colors if enabled
    if [[ "$use_color" == "true" ]]; then
        if [[ "$focused" == "true" ]]; then
            # Bold yellow for focused
            echo "\033[1;33m$node_display\033[0m"
        elif [[ "$state" == "floating" ]]; then
            # Cyan for floating
            echo "\033[36m$node_display\033[0m"
        elif [[ "$state" == "fullscreen" ]]; then
            # Green for fullscreen
            echo "\033[32m$node_display\033[0m"
        else
            echo "$node_display"
        fi
    else
        echo "$node_display"
    fi
}

tree-render() {
    local desktop="$1"
    local use_color="${2:-true}"

    # Get desktop name
    local desktop_name
    desktop_name=$(bspc query -D -d "$desktop" --names)

    echo "Desktop: $desktop_name"
    echo ""

    # Get desktop tree
    local tree_json
    tree_json=$(bspc query -T -d "$desktop" 2>/dev/null)

    if [[ -z "$tree_json" ]]; then
        echo "  (empty)"
        return
    fi

    # Parse tree and render
    tree-render-node "$tree_json" "" "true" "$use_color"
}

tree-render-node() {
    local node_json="$1"
    local prefix="$2"
    local is_last="${3:-true}"
    local use_color="${4:-true}"

    # Check if node or internal node
    local client
    client=$(echo "$node_json" | jq -r '.client // null')

    if [[ "$client" != "null" ]]; then
        # Leaf node (window)
        local node_id
        node_id=$(echo "$node_json" | jq -r '.id // ""')

        if [[ -n "$node_id" ]]; then
            local node_info
            node_info=$(tree-get-node-info "$node_id")

            local node_display
            node_display=$(tree-format-node "$node_info" "$use_color")

            if [[ "$is_last" == "true" ]]; then
                echo "${prefix}└─ $node_display"
            else
                echo "${prefix}├─ $node_display"
            fi
        fi
    else
        # Internal node (container)
        local first_child
        local second_child
        local split_type

        first_child=$(echo "$node_json" | jq -r '.firstChild // null')
        second_child=$(echo "$node_json" | jq -r '.secondChild // null')
        split_type=$(echo "$node_json" | jq -r '.splitType // "vertical"')

        if [[ "$first_child" != "null" ]]; then
            local new_prefix="$prefix"
            if [[ -n "$prefix" ]]; then
                if [[ "$is_last" == "true" ]]; then
                    new_prefix="${prefix}  "
                else
                    new_prefix="${prefix}│ "
                fi
            fi

            # Render first child
            tree-render-node "$first_child" "$new_prefix" "false" "$use_color"
        fi

        if [[ "$second_child" != "null" ]]; then
            local new_prefix="$prefix"
            if [[ -n "$prefix" ]]; then
                if [[ "$is_last" == "true" ]]; then
                    new_prefix="${prefix}  "
                else
                    new_prefix="${prefix}│ "
                fi
            fi

            # Render second child
            tree-render-node "$second_child" "$new_prefix" "true" "$use_color"
        fi
    fi
}

tree-render-all() {
    local use_color="${1:-true}"

    # Get all desktops
    local desktops
    desktops=($(bspc query -D --names))

    for desktop in "${desktops[@]}"; do
        tree-render "$desktop" "$use_color"
        echo ""
    done
}

# ============================================================================
# MAIN
# ============================================================================

tree-main() {
    # Parse options
    local desktop="focused"
    local monitor="focused"
    local show_all=false
    local use_color=true
    local output_format="tree"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                tree-help
                return 0
                ;;
            -d|--desktop)
                desktop="$2"
                shift 2
                ;;
            -m|--monitor)
                monitor="$2"
                shift 2
                ;;
            --all)
                show_all=true
                shift
                ;;
            --no-color)
                use_color=false
                shift
                ;;
            --json)
                output_format="json"
                shift
                ;;
            -*)
                echo "Error: Unknown option: $1" >&2
                tree-help
                return 2
                ;;
            *)
                echo "Error: Unknown argument: $1" >&2
                tree-help
                return 2
                ;;
        esac
    done

    # Check if bspwm is running
    if ! bspwm-is-running; then
        bsp-log-error "bspwm is not running"
        return 1
    fi

    # Output format
    if [[ "$output_format" == "json" ]]; then
        if [[ "$show_all" == "true" ]]; then
            bspc query -T
        else
            bspc query -T -d "$desktop"
        fi
        return 0
    fi

    # Render tree
    if [[ "$show_all" == "true" ]]; then
        tree-render-all "$use_color"
    else
        tree-render "$desktop" "$use_color"
    fi
}

# ============================================================================
# ENTRY POINT
# ============================================================================

tree-main "$@"
